⭐️ 적시에 방어적 복사본을 만들라

1️⃣ 개요 : 자바는 안전한 언어다. 자바를 쓰는 즐거움 🥰 C, C++ 같이 안전하지 않은 언어에서 흔히 보는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다
        자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜진다. 메모리 전체를 하나의 거대한 배열로 다루는 언어에서 누릴 수 없는 강점이다.

        하지만 아무리 자바라 해도 다른 클래스로부터 침범을 아무런 노력 없이 다 막을 수 있는 건 아니다. 그러니 클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로
        프로그래밍해야 한다.

2️⃣ 방어적 복사본이 필요한 경우
        Date가 가변이기 때문에 불변식을 무너드릴 수 있다.
        하지만 Date 대신 불변인 Instant를 사용하면 된다. (혹은 LocalDateTime이나 ZonedDateTime으르 사용해도 된다.)
        Date는 낡은 API이니 새로운 코드를 작성할 때는 더 이상 사용하면 안된다.

        외부 공격으로부터 Period 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다. 그런 다음 Period 인스턴스 안에서는 복사본을 사용한다.

        순서가 부자연스러워보이지만 방어적 복사본을 만들고 그 이후에 유효성을 검사해야 한다.
        멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 순가에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
        방어적 복사를 매개변수 유효성 검사 전에 수행하면 이런 위험에서 해방될 수 있다. 컴퓨터 보안 커뮤니티에서는 이를 검사시점 / 사용시점 공격 혹은 TOCTOU 공격이라 한다.

        Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다.

        매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.

3️⃣ 생성자를 이용할 경우
        생성자를 사용하면 앞서의 공격을 막아낼 수 있지만 Period 인스턴스는 아직도 변경 가능하다. 접근자 메서드가 내부의 가변 정보를 직접 드러내기 때문이다.
        p.end().setYear(78) -> Period 클래스의 변수인 p의 내부를 변경할 수 있다.

4️⃣ 가변 필드의 방어적 복사본을 반환할 경우
        public Date start() { return new Date(start.getTime()); }
        public Date start() { return new Date(end.getTime()); }
        새로운 접근자를 갖추면 Period는 완전한 불변이 된다. 불변식을 위배할 방법이 없다.(네이티브 메서드나, 리플렉션 같은 수단을 제외하고는) 모든 필드가 객체 안에 완벽히 캡슐화되었다.

5️⃣ 매개변수를 방어적으로 복사하는 목적2
        메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지 생각해야 한다.
        변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보고 확신할 수 없다면 복사본을 만들어 저장해야 한다.
        ❗️ 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야 한다. 안심할 수 없다면 방어적 복사본을 반환해야 한다. 길이가 1이상인 배열은 무조건 가변이다.
        (계속 같은 부분) 내부에서 사용하는 배열을 클라이언트에 반환할 때는 항상 방어적 복사를 수행해야 한다. 혹은 배열의 분변 뷰를 반환하는 방법도 있다.

6️⃣ 교훈
        "되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다."
        자바 8 이상으로 개발해도 된다면 Instant(혹은 LocalDateTime이나 ZonedDateTime)를 사용하라.
        이전 버전의 자바를 사용한다면 Date 참조 대신 Date.getIime()이 반환하는 long 정수를 사용하는 방법을 써도 된다.

7️⃣ 생각할 부분
        방어적 복사에는 성능 저하가 따르고, 항상 쓸 수 있는 것도 아니다.
        호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.
        이러한 상황이라도 호출자에서 해당 매개변수나 반환값을 수정하지 말아야 함을 명확히 문서화하는 게 좋다.
        통제권을 이전하는 메서드를 호출하는 클라이언트는 해당 객체를 더 이상 직접 수정하는 일이 없다고 약속해야 한다.
        클라이언트가 건네주는 가변 객체의 통제권을 넘겨받는다고 기대하는 메서드나 생성자에서도 그 사실을 확실히 문서에 기재해야 한다.
        래퍼 클래스 패턴 : 클라이언트는 래퍼에 넘긴 객체에 직접 접근할 수 있고 불변식을 파괴할 수 있지만 그 영향은 오직 클라이언트 자신만 받게 된다.

📖 핵심 정리: 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 복사 비용이 너무 크거나 클라이언트가 그 요소를
        잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.
        

        



