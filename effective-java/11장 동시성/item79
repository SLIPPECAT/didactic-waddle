⭐️ 과도한 동기화는 피하라

1️⃣ 개요
    - 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고 심지어 예측할 수 없는 동작을 낳기도 한다.

    - 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.
    ex. 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.

2️⃣ 과도한 동기화
    - 기본 규칙 : 은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.
    - 모든 코어가 메모리를 일관되게 보기 위한 지연시간이라는 비용이들며, 가상먼시의 코드 최적화를 제한한다는 점도 과도한 동기화의 또 다른 숨은 비용이다.

3️⃣ 가변 클래스를 작성할 때의 두 가지 선택지
    1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하기  ... java.util
    2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들기(item82), 단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 사용 ... java.util.concurrent
 
    ex. StringBuffer(내부적으로 동기화 수행) -> StringBuilder (동기화하지 않은 StringBuffer)
        java.util.Random -> java.tuil.concurrent.ThreadLocalRandom

    선택하기 어렵다면 동기화하지 말고 대신 문서에 "스레드 안전하지 않다"고 명기하기

4️⃣ 클래스를 내부에서 동기화하기로 한 경우
    - 락 분할, 락 스트라이핑, 비차단 동시성 제어 등 다양한 기법을 동원해 동시성을 높여줄 수 있다.

    여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화해야 한다.
    그런데 클라이언트가 여러 스레드로 복제돼 구동되는 상황이라면 다른 클라이언트에서 이 메서드를 호출하는 걸 막을 수 없으니 외부에서 동기화할 방법이 없다.
    결과적으로, 이 정적 필드가 심지어 private라도 서로 관련 없는 스레드들이 동시에 읽고 수정할 수 있게 된다. (사실상 전역 변수와 같아진다.)

📖 핵심 정리 : 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 일반화해 이야기하면, 동기화 영역 안에서의 작업은 최소한으로 줄이자.
            가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자. 멀티코어 세상인 지금은 과도한 동기화를 피하느 ㄴ게 어느 때보다 중요하다. 합당한 이유가 있을 때만
            내부에서 동기화하고, 동기화했는지 여부를 문서에 명확히 밝히자(itme82)


