⭐️ 커스텀 직렬화 형태를 고려해보라

1️⃣ 개요
    - 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리스 때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.
      기본 직렬화 형태를 버릴 수 없게 되는 것이다. 실제로도 BigInteger 같은 일부 자바 클래스가 이 문제에 시달리고 있다.
  
    - 고민해보고 괜찮다고 판단할 때만 기본 직렬화 형태를 사용하라. 직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.
      이상적인 직렬화 형태라면 물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.
  
    - 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
  
    - 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.
  
    ✅ 클래스의 직렬화 형태에 포함되는 공개 API의 경우 문서화해야 한다. private 필드의 설명을 API 문서에 포함하라고 자바독에 알려주는 역할은
      @serial 태그가 한다. @serial 태그로 기술한 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록된다.

2️⃣ 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용할 경우 생기는 4가지 문제
    1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
    2. 너무 많은 공간을 차지할 수 있다.
    3. 시간이 너무 많이 걸릴 수 있다.
    4. 스택 오버플로를 이릉킬 수 있다.

3️⃣ 커스텀 방법 방법
    - 기본 직렬화 사용 여부와 상관없이 객체 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.
    - 어떤 직렬화 형태를 선택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.(item86)
      prviate static final long serailVersionUID = <무작위로 고른 long 값>;
    - 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하거는 직렬 버전 UID를 절대 수정하지 말자.

📖 핵심 정리
    - 클래스를 직렬화하기로 했다면(item86) 어떤 직렬화 형태를 사용할지 심사숙고하기 바란다. 자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만
      사용하고, 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안하라. 직렬화 형태도 공개 메서드(item51)를 설계할 때에 준하는 시간을 들여 설계해야 한다.
      한번 공개된 메서드는 향후 릴리스에서 제거할 수 없듯이, 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다. 직렬화 호환성을 유지하기 위해 영원히 지원해야 하는 것이다.
      잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.
