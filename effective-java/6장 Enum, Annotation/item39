⭐️ 명명 패턴보다 애너테이션을 사용하라

📖 개요 : 전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해왔다. 

1️⃣ 명명 패턴의 단점 1. 오타가 나면 안된다.
                2. 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다.
                3. 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다

                이를 해결해주는 멋진 개념으로, JUnit도 버전 4부터 전면 도입하였다.
                Test라는 이름의 애너테이션을 정의한다고 할 때, 자동으로 수행되는 간단한 테스트용 애터네이션으로 예외가 발생하면 해당 테스트를 실패로 처리한다.

 2️⃣ 애너테이션 : @Test 애너테이션 타입 선언 자체에도 두 가지의 다른 애너테이션이 달려 있다. @Retention과 @Target이다.
              이처럼 애너테이션 선언에 다는 애너테이션을 메타애너테이션이라고 한다. 메타애너테이션을 생략하면 테스트 도구는 @Test를 인식할 수 없다.
              @Retention 메타애너테이션을 생략하면 테스트 도구는 @Test가 반드시 메서드 선언에서만 사용해야 한다고 알려준다. (클래스, 필드 선언 x)

              @Test가 적용된 모습을 보면 "아무 매개변수 없이 단순히 대상에 마킹"을 하고 있는데 그런 의미에서 마커(marker) 애너테이션이라 한다.
              이 애너테이션을 사용하면 프로그래머가 Test이름에 오타를 내거나 메서드 선언 외의 프로그램 요소에 달면 컴파일 오류를 내준다.

              자바 8에서는 여러 개의 값을 받는 애너테이션을 다른 방식으로 만들 수 있다. 배열 매개변수를 사용하는 대신 애너테이션에 @Repeatable 메타애너테이션을 다는 방식이다.
              @Repeatable을 단 애너테이션은 단 하나의 프로그램 요소에 여러 번 달 수 있다. 주의할 점이 있다.
              ❗️ 주의점1. @Repeatable을 단 애너테이션을 반환하는 '컨테이너 애너테이션'을 하나 더 정의하고 @Repeatable에 이 컨테이너 애너테이션의 class 객체를 매개변수로
                        전달해야 한다.
                 주의점2. 컨테이너 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의해야 한다.
                 주의점3. 컨테이너 애너테이션 타입에는 적절한 보존 정책(@Retention)과 적용 대상(@Target)을 명시해야 한다. 그렇지 않으면 컴파일되지 않을 것이다.

              반복 가능한 애너테이션은 처리할 때도 주의를 요한다. 반복 가능 애너테이션을 여러 개 달면 하나만 달았을 때와 구분하기 위해 해당 '컨테이너' 애너테이션 타입이 적용된다.
              getAnnotationByType 메서드는 둘을 구분하지 않지만, isAnnotationPresent 메서드는 둘을 명확히 구분한다.

              반복 가능 애너테이션을 사용해 하나의 프로그램 요소에 같은 애너테이션을 여러 번 달면 코드 가독성을 개선할 수 있다. 하지만, 애너테이션을 선언하고 이를 처리하는 부분에는
              코드 양이 늘어나며, 특히 처리 코드가 복잡해져 오류가 날 가능성이 커질 수 있다.

              다른 프로그래머가 소스코드에 추가 정보를 제공할 수 있는 도구를 만드는 일을 한다면 적당한 애너테이션 타칩도 함께 정의해 제공하자. 애터테이션으로 할 수 있는 일을
              명명 패턴으로 처리할 이유는 없다.
