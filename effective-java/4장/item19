⭐️ 상속을 고려해서 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

아이템 18에서는 상속을 염두에 두지 않고 설계했고 상속할 떄의 주의점도 문서화해놓지 않은 '외부' 클래스를
상속할 떄의 위험을 경고했다. 여기서 '외부'란 프로그래머의 통제권 밖에 있어 어떻게 변경될지 모른다는 뜻이다.

그렇다면 상속을 고려한 설계와 문서화란 정확히 무엇을 의미할까?

우선, 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
달리 말하면, 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨애 한다.
재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
예를 들어 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있다.

API 문서 메서드 설명 끝에 종종 'Implementation Requirements'로 시작하는 절을 볼 수 있는데 그 메서드의 내부 동작 방식을 설명하는 곳이다.
메서드 주석에 @impleSpec 태그를 붙여주면 자바독 도구가 생성해준다.

상속이 캡슐화를 해칠 수 있다.
클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로
공개해야 할 수도 있다. 드물개는 protected 필드로 공개해야 할 수도 있다. java.util.AbstractList의 removeRange 메서드를 예로 살펴보자.

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다. 
상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.
상속을 금지하는 방법은 두 가지다.
1. 둘 중 더 쉬운 클래스를 final로 선언하는 방법이다.
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법이다.
정적 팩터리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 준다.

매서드를 재정의 하지 않게 하고 문서로 남기기

클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법
먼저, 각각의 재정의 가능 메서드는 자신의 본문 코드를 private '도우미 메서드'로 옮기고, 이 도우미 메서드를 호출하도록 수정한다.
그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 된다.

핵심 정리
상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지 (자기사용 패턴) 모든 문서로 남겨야 하며,
일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그렇지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 할 수 있다.
다른 이가 효율 좋은 하위 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하거나
생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.
