finalizer와 cleaner 사용을 피하라

자바는 두 가지 객체 소멸자를 제공한다.

그 중 finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
오동작,  이식성 문제의 원인이 되기도 한다.

자바 9에서는 finalizer를 deprecated API로 지정하고 cleaner를 그 대안으로 소개했다.

cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.

C++ 의 desturctor와는 다른 개념으로, C++에서 파괴자는 자원 회수를 위한 보편적 방법이다.

자바에서는 접근할 수 없게 된 객체를 회수하는 역할을 가비지 컬렉터가 담당하고, 프로그래머에게는 아무런 작업도 요구하지 않는다.
C++의 파괴자는 비메모리 자원을 회수하는 용도로도 쓰인다.
Java에서는 try-with-resources와 try-finally를 사용해 해결한다.

finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다.
이 두 가지의 수행에 대해서는 전적으로 GC의 알고리즘에 달렸다.

finalizer와 cleaner는 심각한 성능 문제도 동반한다.

finalizer를 사용한 클래스는 finalizeer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. finalizer 공격 원리는 간단하다.
생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.

System.exit을 호출할 때의 cleaner 동작은 구현하기 나름이다. 청소가 이뤄질지는 보장하지 않는다.
System.gc()를 추가함으로써 "방 청소"를 출력할 수 있다.

핵심 정리
cleaner(java 8까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.
