⭐️ 한정적 와일드카드를 사용해 API 유연성을 높이라

1️⃣ 개요 : 매개변수화 타입은 불공변이다. 즉, 서로 다른 타입 Type1ㅘ Type2가 있을 때 List<Type1>은 List<Type2>의 하위 타입도 상위 타입도 아니다.
        List<String>은 List<Object>의 하위 타입이 아니라는 뜻인데, 곰곰이 따져보면 사실 이쪽이 말이 된다.
        List<Object>에는 어떤 객체든 넣을 수 있지만 List<String>에는 문자열만 넣을 수 있다.
        즉, List<String>은 List<Object>가 하는 일을 제대로 수행하지 못하니 하위 타입이 될 수 없다. (리스코프 치환 원칙에 어긋난다.)
        때론, 불공변 방식보다 유연한 무언가가 필요하다.

한정적 와일드카드 타입이라는 특별한 매개변수화 타입을 지원한다.
pushAll의 입력 매개변수 타입은 'E의 Iterable'이 아니라 'E의 하위 타입의 Iterable'이어야 하며, 와일드 카드 타입 Iterable<? extends E>가 정확히 이런 뜻이다.
popAll의 입력 매개변수의 타입이 'E의 Collection'이 아니라 'E의 상위 타입의 Collection'이어야 한다(모든 타입은 자기 자신의 상위 타입니다.) Collection<? super E>

유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라 한편, 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없다.
타입을 정확히 지정해야 하는 상황으로, 이때는 와일드카드 타입을 쓰지 말아야 한다.

2️⃣ 공식 : 펙스(PECS): prducer-extends, consumer-super
        매개변수화 타입 T가 생상자라면 <? extends T>를 사용하고, 소비자라면 < super T>를 사용하라. (Get and Put Principle)

반환 타입에는 한정적 와일드카드 타입을 사용하면 안 된다. 유연성을 높여주긴는커녕 클라이언트 코드에서도 와일드카드 타입을 써야 하기 때문이다.

클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.

비한정적 타입 매개변수 vs 비한정적 와일드카드

기본규칙 : 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하라. 이 때 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 된다.

private : 와일드카드 타입을 실제 타입으로 바꿔주는 private 도우미 메서드

📖 핵심 정리 : 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다. 그러니 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다.
            PECS 공식을 기억하자. 즉, 생산자는 extends 소비자는 super를 사용한다. Comparable과 Comparator는 모두 소비자라는 사실도 잊지 말자.
