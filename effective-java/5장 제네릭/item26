⭐️ 로 타입은 사용하지 말라
로 타입: 매개 변수가 없는 제네릭 타입 ex. List a = new ArrayList<>();

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.

예컨대 List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다. 그래서 이 인터페이스의 완전한 이름은 List<E>지만, 짧게 그냥 List라고도 자주 쓴다.
제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭타입이라 한다.

각가의 제네릭 타입은 일련의 매개변수화 타입을 정의한다. 먼저 클래스 이름이 나오고 이어서 꺾쇠 괄호 안에 실제 타입 매개변수들을 나열한다.
예컨대 List<String>은 원소의 타입인 String인 리스트를 뜻하는 매개변수화 타입이다. 여기서 String이 정규 타입 매개변수 E에 해당하는 실제 타입 매개변수다.

마지막으로, 제네릭 타입을 하나 정의하면 그에 딸린 로 타입도 함께 정의된다. 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 때를 말한다.
예컨대 List<E>의 로 타입은 List다. 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.

제네릭을 활용하면 오류에 대한 정보가 타입 선언 자체에 녹아든다. -> 이로 인해 타입 안정성 확보가 가능하다!

로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
로 타입은 그럼 왜 만들어 놓은 걸까? -> 호환성 때문.
기존 코드를 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야 했다.
로 타입을 사용하는 메서드에 매개변수화 타입의 인스턴를 넘겨도 동작해야만 했던 것이다.
이 마이그레이션 호환성을 위해 로 타입을 지원하고 제네릭 구현에는 소거 방식을 사용하기로 했다.

List 같은 로 타입은 사용해서는 안 되나 List<Object>처럼 임의 객체를 혀용하는 매개변수화 타입은 괜찮다.
로 타입인 List와 매개변수화 타입인 List<Object>의 차이는 무엇일까? 간단히 이야기하자면, List는 제네릭 타입에서 완전히 발을 뺀 것이고,
List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다. 매개변수로 List를 받는 메서드에 List<String>을 넘길 수 있지만
List<Object>를 받는 메서드를 넘길 수 없다. 이는 제네릭의 하위 타입 규칙 때문이다. 즉, List<String>은 로 타입인 List의 하위 타입이지만, List<Objcect>의 하위 타입은 아니다.

그 결과, List<Object> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안정성을 잃게 된다.

비한정적 와일드카드 타입을 사용하는 방법도 있다.
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자. 예컨대 제네릭 타입인 Set<E>의 비한정적 와일드카입의 타입은 Set<?>다.
이것이 어던 타입이라도 담을 수 있는 가장 범용적인 매개변수화 Set 타입이다.

둘의 차이는 무엇일까?
와일드카드 타입은 안전하고, 로 타입은 안전하지 않다. 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.
반면, Collection<?>에는 (null 외에는) 어떤 원소도 넣을 수 없다. 다른 원소를 넣으려 하면 컴파일할 때, 오류 메시지를 보게 된다.

컬렉션의 타입 불변식을 훼손하지 못하게 막았다. 

로 타입을 쓰지 말라는 규칙에도 소소한 예외가 몇 개 있다.
<예외1>
class 리터럴에는 로 타입을 써야 한다. 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다. (배열과 기본 타입은 허용)
에를 들어 List.class, String[].class, int.class는 허용하고 Lsit<String>.class와 List<?>.class는 허용하지 않는다.
<예외2>
instanceof 연산자와 관련이 있다. 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
그리고 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다. 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로,
차리리 로 타입을 쓴느 편이 깔끔하다.

핵심 정리
로 타입을 사용하면 런타임에 예외가 생길 수 있으니 사용하면 안된다.
로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
빠르게 훑어보자면 Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고, Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다. 그리고 이들의 로 타입인
Set은 제네릭 타입 시스템에 속하지 않는다. Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.

