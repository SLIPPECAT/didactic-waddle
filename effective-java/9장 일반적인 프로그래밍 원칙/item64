⭐️ 객체는 인터페이스를 사용해 참조하라

(item51) 매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라. 
-> "객체는 클래스가 아니라 인터페이스로 참조하라"로 확장

1️⃣ 개요 : 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
        객체의 실제 클래스를 사용해야 할 상황은 '오직' 생성자로 생성할 때뿐이다.

2️⃣ Set 인터페이스를 구현한 LinkedHashSet 변수 선언 예시
    ex1. 좋은 예: 인터페이스를 타입으로 사용
          Set<Son> sonSet = new LinkedHashSet();

    ex2. 나쁜 예: 클래스를 타입으로 사용
          LinkedHashSet<Son> sonSet = new LinkedHashSet();

    인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.
    나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자(혹은 다른 정적 펙터리)를 호출해주면 된다.

    ❗️ 주의할 점 : 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운
                클래스도 반드시 같은 기능을 제공해야 한다.

            ex) 첫번째 선언의 주변 코드가 LinkedHashSet이 따르는 순서 정책을 가정하고 동작하는 상황에서 이를 HashSet으로 바꾸면 문제가 될 수 있다.
                HashSet이 반복자의 순회 순서를 보장하지 않기 때문이다.

3️⃣ 적합한 인터페이스가 없는 경우
    1. 값 클래스는 클래스로 참조해야 한다. ex. String, BigInteger

    2. 클래스 기반으로 작성된 프레임워크들이 제공하는 객체들이다.
      이런 경우라도 특정 구현 클래스보다는 (보통은 추상 클래스인) 기반 클래스를 사용해 참조하는 게 좋다. ex. OutputStream

    3. 인터페이스에는 없는 특별한 메서드를 제공하는 클래스 ex. PriorityQueue 클래스는 Queue에는 없는 comparator 메서드를 제공

    🧐 실전에서는 주어진 객체를 표현할 적절한 인터페이스가 있는지 찾아서 그 인터페이스로 참조하면 더 유연하고 세련된 프로그램을 만들 수 있다.
      적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.
