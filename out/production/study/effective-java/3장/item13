clone 재정의는 주의해서 진행하라

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만 아쉽게도 의도한 목적을 제대로 이루지 못했다.

메서드 하나 없는 Cloneable 인터페이스는 무슨 일을 할까?
놀랍게도 이 인터페이스는 protected 메서드인 clone의 동작 방식을 결정한다.

Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에 호출하면
CloneNotSupportedException을 던진다. 이는 인터페이스를 상당히 이례적으로 사용한 예이니 따라하지는 말자.

clone메서드는 사실상 생성자와 같은 효과를 낸다.

배열을 복제할 때는 배열의 clone 메서드를 사용하길 권장한다.
배열은 clone 기능을 제대로 사용하는 유일한 예라 할 수 있다.

Cloneable 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다(단 원본과 복제된 객체가 그 가변 객체를 공유해도 안전하다면 괜찮다.)

해시테이블의 내부는 버킷들의 배열이고, 각 버킷은 키-값 쌍을 담는 연결 리스트의 첫 번째 리스트를 참조한다.

복잡한 가변 객체를 복제하는 마지막 방법
머넞 super.clone을 호출하여 얻은 객체의 모든 필드를 초기 상태로 설정한 다음, 원본 객체의 상태를 다시 생성하는 고수준 메서드들을 호출.
HashTable 예에서라면 buckets 필드를 새로운 버킷 배열로 초기화한 다음 원본 테이블에 담긴 모든 키-값 쌍 각각에 대해 복제본 테이블의
put(key, value) 메서드를 호출해 둘의ㅏ 내용이 똑같게 해주면 된다. 

복사 생성자와 복사 팩터리는 Cloneable/clone 방식보다 나은 면이 많다.
언어 모순적이고 위험천만한 객체 생성 매커니즘을 사용하지 않으며, 엉성하게 문서화된 규약에 기대지 않고, 정상적인 final 필드 용법과도 충돌하지 않으며, 불필요한 검사 예외를 던지지 않고, 형변환도
필요치 않다.

복사 생성자와 복사 팩터리의 더 정확한 이름은 변환 생성자, 변환 팩터리이다.

이들을 이용하여 클라이언트는 원본 구현 타입에 얽매이지 않고 복제본의 타입을 직접 선택할 수 있다.
HashSet 객체 s를 TreeSet 타입으로 복제할 수 있다. clone으로는 불가능한 이 기능을 변환 생성자로는 간단히 new TreeSet<>();으로 처리할 수 있다.


핵심 정리
Cloneable이 몰고 온 모든 문제를 되짚어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 되며,
새로운 클래스도 이를 구현해서는 안 된다. final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후
별다른 문제가 없을 때만 드물게 허용해야 한다. 기본 원칙은 '복제 기능은 생성자와 팩터리를 이용하는 게 최고'라는 것이다 단 배열만은 clone메서드 방식이 가장 깔끔한,
이 규칙의 합당한 예외라 할 수 있다.
