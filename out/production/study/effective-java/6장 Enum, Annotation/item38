⭐️ 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

1️⃣ 개요 : 열거 타입은 거의 모든 상황에서 책 초반에 소개한 타입 안전 열거 패턴 보다 우수하다. 단, 예외가 하나 있으니, 타입 안전 열거 패턴은 확장할 수 있으나 열거 타입은 그럴 수
        없다는 점이다. 
        확장할 수 있는 열거 타입이 어울리는 쓰임이 최소한 하나는 있다. 바로 연산 코드다. 연산 코드의 각 원 소는 특정 기계가 수행하는 연산을 뜻한다. 이따금 API가 제공하는 기본 연산
        외에 사용자 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있다. 열거 타입으로 이 효과를 낼 수 있다.
        기본 아이디어는 열거 타입이 임의의 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다. 연산 코드용 인터페이스를 정의하고 열거 타입이 이 인터페이스를 구현하게 된다.

        class 리터럴은 한정적 타입 토큰 역할, opEnumType 매개변수의 선언 (<T extends Enum<T> & Operation> Class<T>),
        Class 객체가 열거 타입인 동시에 Operation의 하위 타입이어야 한다는 뜻. 열거 타입이어야 원소를 순회할 수 있고, Operation이어야 원소가 뜻하는 연산 수행 가능

        Class 객체 대신 한정적 와일드카드 타입인 Collection<? extends Operation>을 넘기는 방법
        사소한 문제: 열거 타입끼리 구현을 상속할 수 없다는 점
        중복량이 많다면 별도의 도우미 클래스나 정적 도우미 메서드로 분리하는 방식으로 코드 중복을 없앨 수 있다.
        자바 라이브러리에서도 java.nio.file.LinkOption 열거 타입은 CopyOption, OpenOption 인터페이스르 구현했다.

📖 핵심 정리 : 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다. 이렇게 하면 클라이언트는 이 인퍼페이스를
            구현해 자신만의 려거 타입(혹은 다른 ㅌ타입)을 만들 수 있다. 그리고 API가 (기본 열거 타입을 직접 명시하지 않고) 인터페이스 기반으로 작성되었다면 기본 열거 타입의
            인스턴스가 쓰이는 모든 곳을 새로 확장한 열거 타입의 인스턴스로 대체해 사용할 수 있다.
