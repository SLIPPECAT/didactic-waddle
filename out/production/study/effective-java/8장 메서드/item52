⭐️ 다중정의(오버로딩)는 신중히 사용하라 🟥

1️⃣ 개요 : 다중정의(오버로딩)한 메서드가 여러개 있을 경우 어떤 메서드를 호출할지는 컴파일타임에 정해진다.
          직관과 벗어나는 결과가 나오 이유는 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택되기 때문이다.

2️⃣ 메서드 재정의(오버라이딩) : 메서드 재정의란 상위 클래스가 정의한 것과 똑같은 시그니처의 메서드를 하위 클래스에서 다시 정의한 것을 말한다.
                    메서드를 재정의한 다음 '하위 클래스와 인스턴스'에서 그 메서드를 호출하면 재정의한 메서드가 실행된다. 컴파일 타임에 그 인스턴스의 타입이 무엇이었냐는 상관없다.
                    예상한 것과 같은 결과가 실행되는 것을 확인할 수 있다.

3️⃣ 다중정의(오버로딩) : 다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요치 않다. 선택은 컴파일타임에, 오직 매개변수의 컴파일타임 타입에 의해 이루어진다.

4️⃣ 고려할 점 : 프로그래머에게 재정의가 정상적인 동작 방식이고 다중정의가 예외적인 동작으로 보일 수 있을 것이다. (기대한 결과에 비추어보았을 때)
          헷갈릴 수 있는 코드는 작성하지 않는 게 좋고, 특히 공개 API라면 더욱 신경 써야 한다. API 사용자가 매개변수를 넘기면서 어떤 다중정의 메서드가 호출될지 모른다면
          프로그램이 오동작하기 쉽다. 다중정의가 혼동을 일으키는 상황을 피해야 한다.
          ❗️ 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자. 가변 인수를 사용하는 메서드라면 다중 정의를 아예 하지 말아야 한다.
          ❗️ 다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 항상 열려있다.

5️⃣ 다중정의가 아닌 모든 메서드에 다른 이름을 지어주는 경우
          - ex. ObjectOutputStream 클래스의 write 메서드
                    read메서드의 이름과 짝을 맞추기 좋다.

6️⃣ 생성자에서의 다중정의
          1. 생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다.
          2. 생성자는 재정의할 수 없으니 다중정의와 재정의가 혼용에 대해 걱정하지 않아도 된다.

7️⃣ 생성자가 같은 수의 매개변수를 받아야 하는 경우
          1. 매개변수 중 하나 이상이 "근본적으로 다르다"면 헷갈릴 일이 없다. (서로 어느쪽으로든 형변환할 수 없다는 의미)
            ㄴ 이 조건만 충족한다면 어느 다중정의 메서드를 호출할지가 매개변수들의 런타임 타입만으로 결정.

8️⃣ List와 Set에서의 메소드 다중정의
          set.remove(i) : 기대한 대로 동작 (다중정의된 메소드 x)
          list.remove(i) : '저장한 위치'의 원소를 제거하는 기능, 0번째, 1번째, 2번째 원소를 제거 (제거한 이후에는 다시 위치를 카운팅)
          list.remove((Integer) i ) : 기대한 방식대로 출력된다.
          제네릭과 오토박싱이 등장하면서 두 메서드의 매개변수 타입이 더는 근본적으로 다르지 않게 되었다. 자바 언어에 제네릭과 오토박싱을 더한 결과 List인터페이스가 취약해졌다.

9️⃣ 람다와 메서드 참조
          문제의 원인 : System.out::println은 부정확한 메서드 참조다. "암시적 타입 람다식"이나 부정확한 메서드 참조 같은 인수 표현식은 목표 타입이 선택되기 전에는
                    그 의미가 정해지지 않기 때문에 적용성 테스트 때 무시된다. 핵심은 다중정의된 메서드(또는 생성자)들이 함수형 인터페이스를 인수로 받을 때, 비록 서로
                    다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생긴다는 것이다. 
          ❗️ 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다. 서로 다른 함수형 인터페ㅣ이스라도 서로 근본적으로 다르지 않다.


                    
          

          
